# 添加插件
![[Pasted image 20240327205657.png]]

# clone
```
git clone http://git.yvanui.com/luoyifan/obsidian-api-request.git
```

# 添加脚本
```
getDoc
http://localhost:8085/api/com/galaxis/wms/ob/Doc@buildDoc

找到文件夹,覆盖 main.js
note_repo\.obsidian\plugins\api-request
```


```js
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MainAPIR
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  URL: "https://jsonplaceholder.typicode.com/todos/1",
  FormatOut: "json",
  MethodRequest: "GET",
  DataRequest: "",
  HeaderRequest: '{"Content-Type": "application/json"}',
  DataResponse: "",
  URLs: [],
  Name: ""
};
function nestedValue(data, key) {
  const keySplit = key.split("->").map((item) => item.trim());
  var value = "";
  for (let i = 0; i < keySplit.length; i++) {
    if (i === 0) {
      value = data.json[keySplit[i]];
    } else {
      value = value[keySplit[i]];
    }
  }
  return value;
}
function toDocument(app, settings, editor) {
  const selection = editor.getSelection();
  const r = {
    url: settings.URL,
    method: settings.MethodRequest,
    body: selection
  };
  if (!r.body) {
    r.method = "POST";
    r.body = '{"args":[]}';
  }
  requestUrl(r).then((data) => {
    var _a;
    if (settings.DataResponse !== "") {
      const DataResponseArray = settings.DataResponse.split(",");
      for (let i = 0; i < DataResponseArray.length; i++) {
        const key = DataResponseArray[i].trim();
        var value = JSON.stringify(data.json[key]);
        if (key.includes("->")) {
          value = nestedValue(data, key);
        }
        if (settings.FormatOut === "variable") {
          value = JSON.stringify(value);
          editor.replaceSelection(`${key.split("->").pop()} : ${value}
`);
        }
        if (settings.FormatOut === "json") {
          if (key.includes("->")) {
            value = JSON.stringify(value);
          }
          editor.replaceSelection(`\`\`\`json
${key.split("->").pop()} : ${value}
\`\`\`

`);
        }
      }
    } else {
      if (settings.FormatOut === "variable") {
        const response = data.json;
        if (!((_a = response == null ? void 0 : response.data) == null ? void 0 : _a.success)) {
          new import_obsidian.Notice("Server response error");
        }
        const responseData = response.data;
        editor.insertText(responseData.content);
        const file = editor.getDoc().editorComponent.file;
        const path = file.parent.path;
        const vault = file.vault;
        const promiseAll = [];
        let createCount = 0;
        let modifyCount = 0;
        Object.keys(responseData.files).forEach((key) => {
          const targetFile = vault.getAbstractFileByPath(path + "/" + key + ".md");
          if (targetFile) {
            promiseAll.push(vault.modify(targetFile, responseData.files[key], {}));
            modifyCount++;
          } else {
            promiseAll.push(vault.create(path + "/" + key + ".md", responseData.files[key], {}));
            createCount++;
          }
        });
        Promise.all(promiseAll).then((res) => {
          new import_obsidian.Notice("\u5168\u90E8\u5199\u5165\u6210\u529F, \u4E00\u5171" + res.length + "\u4E2A\u6587\u4EF6, \u65B0\u5EFA" + createCount + "\u4E2A, \u4FEE\u6539" + modifyCount + "\u4E2A");
        }).catch((e) => {
          new import_obsidian.Notice("Error: " + e.message);
        });
      }
      if (settings.FormatOut === "json") {
        editor.replaceSelection(`\`\`\`json
${JSON.stringify(data.json)}
\`\`\`
`);
      }
    }
  }).catch((error) => {
    console.error(error);
  });
}
var MainAPIR = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "show-response-in-modal",
      name: "Show response in Modal",
      callback: () => {
        new ShowOutputModal(this.app, this.settings.URL, this.settings.MethodRequest, this.settings.DataRequest, this.settings.HeaderRequest, this.settings.DataResponse).open();
      }
    });
    try {
      this.registerMarkdownCodeBlockProcessor("req", async (source, el, ctx) => {
        const sourceLines = source.split("\n");
        let method = "GET";
        let allowedMethods = ["GET", "POST", "PUT", "DELETE"];
        let URL = "";
        let show = "";
        let header = {};
        let body = {};
        let format = "{}";
        let responseType = "json";
        for (const line of sourceLines) {
          let lowercaseLine = line.toLowerCase();
          switch (true) {
            case lowercaseLine.includes("method: "):
              method = line.replace(/method: /i, "").toUpperCase();
              if (!allowedMethods.includes(method.toUpperCase())) {
                el.innerHTML = "Error: Method " + method + " not supported";
                return;
              }
              break;
            case lowercaseLine.includes("url: "):
              URL = line.replace(/url: /i, "");
              break;
            case lowercaseLine.includes("response-type"):
              responseType = line.replace(/response-type: /i, "").toLowerCase();
              const allowedResponseTypes = ["json", "txt", "md"];
              if (!allowedResponseTypes.includes(responseType)) {
                el.innerHTML = "Error: Response type " + responseType + " not supported";
                return;
              }
              break;
            case lowercaseLine.includes("show: "):
              show = line.replace(/show: /i, "");
              break;
            case lowercaseLine.includes("header: "):
              header = JSON.parse(line.replace(/header: /i, ""));
              break;
            case lowercaseLine.includes("body: "):
              body = line.replace(/body: /i, "");
              break;
            case lowercaseLine.includes("format: "):
              format = line.replace(/format: /i, "");
              if (!format.includes("{}")) {
                el.innerHTML = "Error: Use {} to show response in the document.";
                return;
              }
              break;
          }
          if (URL === "") {
            el.innerHTML = "Error: URL not found";
            return;
          }
        }
        try {
          const formatSplit = format.split("{}");
          let responseData;
          if (method !== "GET") {
            responseData = await requestUrl({ url: URL, method, header, body });
          } else {
            responseData = await requestUrl({ url: URL, method });
          }
          if (responseType !== "json") {
            el.innerHTML = formatSplit[0] + responseData.text + formatSplit[1];
          } else if (!show) {
            el.innerHTML = formatSplit[0] + JSON.stringify(responseData.json, null) + formatSplit[1];
          } else {
            let nesData = show.includes("->") ? nestedValue(responseData, show) : responseData.json[show];
            if (typeof nesData === "object") {
              nesData = JSON.stringify(nesData);
            } else if (typeof nesData === "string") {
              nesData = nesData.replace(/"/g, "");
            }
            el.innerHTML = formatSplit[0] + nesData + formatSplit[1];
          }
        } catch (error) {
          console.error(error);
          el.innerHTML = "Error: " + error.message;
        }
      });
    } catch (e) {
      console.error(e.message);
    }
    this.addCommand({
      id: "response-in-document",
      name: "Paste response in current document",
      editorCallback: (editor, view) => {
        toDocument(this.app, this.settings, editor);
      }
    });
    for (let i = 0; i < this.settings.URLs.length; i++) {
      this.addCommand({
        id: "response-in-document-" + this.settings.URLs[i].Name,
        name: "Response for api: " + this.settings.URLs[i].Name,
        editorCallback: (editor, view) => {
          const rea = this.settings.URLs[i];
          toDocument(this.app, rea, editor);
        }
      });
    }
    this.addSettingTab(new APRSettings(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var ShowOutputModal = class extends import_obsidian.Modal {
  constructor(app, URL, MethodRequest, DataRequest, HeaderRequest, DataResponse) {
    super(app);
    this.props = {
      URL,
      MethodRequest,
      DataRequest,
      HeaderRequest,
      DataResponse
    };
  }
  onOpen() {
    const { contentEl } = this;
    const { URL, MethodRequest, DataRequest, HeaderRequest, DataResponse } = this.props;
    console.log(HeaderRequest);
    if (MethodRequest === "GET") {
      requestUrl({
        url: URL,
        method: MethodRequest,
        headers: JSON.parse(HeaderRequest)
      }).then((data) => {
        if (DataResponse !== "") {
          const DataResponseArray = DataResponse.split(",");
          for (let i = 0; i < DataResponseArray.length; i++) {
            if (DataResponseArray[i].includes("->")) {
              contentEl.createEl("b", { text: DataResponseArray[i] + ` : ${JSON.stringify(nestedValue(data, DataResponseArray[i]))}` });
            } else {
              contentEl.createEl("b", { text: DataResponseArray[i] + ` : ${JSON.stringify(data.json[DataResponseArray[i]])}` });
            }
          }
        } else {
          contentEl.createEl("b", { text: `${JSON.stringify(data.json)}` });
        }
      }).catch((error) => {
        console.error(error);
        contentEl.createEl("b", { text: "Error: " + error.message });
      });
    } else {
      requestUrl({
        url: URL,
        method: MethodRequest,
        headers: JSON.parse(HeaderRequest),
        body: DataRequest
      }).then((data) => {
        if (DataResponse !== "") {
          const DataResponseArray = DataResponse.split(",");
          for (let i = 0; i < DataResponseArray.length; i++) {
            contentEl.createEl("b", { text: DataResponseArray[i] + ` : ${JSON.stringify(data.json[DataResponseArray[i]])}` });
          }
        } else {
          contentEl.createEl("b", { text: `${JSON.stringify(data.json)}` });
        }
      }).catch((error) => {
        console.error(error);
        contentEl.createEl("b", { text: "Error: " + error.message });
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var APRSettings = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.displayAddedURLs(containerEl);
    new import_obsidian.Setting(containerEl).setName("Name").setDesc("Name of the request").addText((text) => text.setPlaceholder("Name").setValue(this.plugin.settings.Name).onChange(async (value) => {
      if (value !== "") {
        this.plugin.settings.Name = value;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("URL").setDesc("Endpoint to fetch data from").addText((text) => text.setPlaceholder("URL").setValue(this.plugin.settings.URL).onChange(async (value) => {
      this.plugin.settings.URL = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Response format").setDesc("Select the desired response format: JSON (as a code block) or Variable (using '::')").addDropdown((dropDown) => {
      dropDown.addOption("json", "JSON");
      dropDown.addOption("variable", "Variable");
      dropDown.setValue(this.plugin.settings.FormatOut);
      dropDown.onChange(async (value) => {
        this.plugin.settings.FormatOut = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Request method").setDesc("Select the desired request method").addDropdown((dropDown) => {
      dropDown.addOption("GET", "GET");
      dropDown.addOption("POST", "POST");
      dropDown.addOption("POST", "PUT");
      dropDown.addOption("DELETE", "DELETE");
      dropDown.setValue(this.plugin.settings.MethodRequest);
      dropDown.onChange(async (value) => {
        this.plugin.settings.MethodRequest = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Data to send").setDesc("Data to send in the request").addTextArea((text) => text.setPlaceholder('{"data":"data"}').setValue(this.plugin.settings.DataRequest).onChange(async (value) => {
      this.plugin.settings.DataRequest = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Headers").setDesc("Headers to send in the request").addTextArea((text) => text.setPlaceholder('{"Content-Type": "application/json"}').setValue(this.plugin.settings.HeaderRequest).onChange(async (value) => {
      this.plugin.settings.HeaderRequest = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Data to show in modal").setDesc("Write the name of the variable to show in the modal (space by comma)").addTextArea((text) => text.setPlaceholder("Variable Name").setValue(this.plugin.settings.DataResponse).onChange(async (value) => {
      this.plugin.settings.DataResponse = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).addButton((button) => {
      button.setClass("mod-cta");
      button.setButtonText("Add this APIR").onClick(async () => {
        const { Name } = this.plugin.settings;
        if (Name === "") {
          new import_obsidian.Notice("Name is empty");
          return;
        }
        const {
          URL,
          FormatOut,
          MethodRequest,
          DataResponse,
          DataRequest,
          HeaderRequest
        } = this.plugin.settings;
        const { URLs } = this.plugin.settings;
        URLs.push({
          "URL": URL,
          "Name": Name,
          "FormatOut": FormatOut,
          "MethodRequest": MethodRequest,
          "DataRequest": DataRequest,
          "HeaderRequest": HeaderRequest,
          "DataResponse": DataResponse
        });
        await this.plugin.saveSettings();
        this.display();
        this.plugin.addCommand({
          id: "response-in-document-" + Name,
          name: "Response for api: " + Name,
          editorCallback: (editor, view) => {
            const rea = URLs[URLs.length - 1];
            toDocument(this.app, rea, editor);
          }
        });
      });
    });
  }
  displayAddedURLs(containerEl) {
    const { URLs } = this.plugin.settings;
    if (URLs.length > 0) {
      containerEl.createEl("p", { text: "Added APIs:" });
      const urlsList = containerEl.createEl("ul");
      URLs.forEach((url) => {
        const urlItem = urlsList.createEl("li");
        urlItem.createEl("code", { text: url.Name + " : " });
        urlItem.createEl("a", { text: url.URL, href: url.URL });
        urlItem.createEl("code", { text: " || " });
        const removeButton = urlItem.createEl("button", {
          text: "\u274C"
        });
        removeButton.addEventListener("click", async () => {
          const index = URLs.indexOf(url);
          URLs.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        });
      });
    }
  }
};
```